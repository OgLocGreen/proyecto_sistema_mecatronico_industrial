In diesem Kapitel wird auf die Software für den Rover eingegangen. 
Auf die verschiedenen Funktionen und Eigenschaften der Software. 
Ein groben überblick über diese Aufgabe kann im Schaubild 1. - BlackBox Rover verschaft werden.
Hier zu sehen sind alle Grobe Baugruppe und die Comunication ob wired or wireless.
Es wird auch auf die Kommunikation der verschiedenen Komponenten und Baugruppen eingegangen.
Zu dem werden die verschiednen Schnittstellen und Variablen erklärt,
 welche für das Projekt nötig waren.
Zur Software selbst werden zum Schluss noch die einzelnen Klassen kurz erklärt. 
Wenn es nötig ist, werden auch einzelne Funktionen erklärt.
Somit Folgen nun Folgende Unterkapitel 
1. Programmierumgebung
2. Struktureller Aufbau der Kommunikation
3. Aufbau der Schnittstellen und Variablen innerhalb des Rovers und der andern Baugruppe
4. Struktureller Aufbau der Software der einzelnen Baugruppen
5. Erklärung der einzelnen Klassen

1. Programmierumgebung
Für die Software wurde die Entscheidung getroffen, dass wir das der BeagleBoneBlack im Mittel Punkt des ganzen Projekts steht.
Zu dem wurde zu Beginn direkt wichtige Eckpunkte zur Entwickelung der Software beschlossen. 
Dazu gehört mich, welchen Programmierumgebungen gearbeitet wird, diese sind tabellarisch in Bild 1 - Programmierumgebungen zu sehen.
Dies ist vor allem dafür wichtig, dass es während des Arbeitens keine Probleme auftauchen.

2. Struktureller Aufbau der Kommunikation
Für die Kommunikation wurden zwei verschiedene Optionen gewählt, welche parallel zueinander Ablaufen.

2.1. Kommunikation für Daten
Für die Kommunikation von Daten, welche zwischen den Baugruppen ausgetauscht werden müssen, wurde ein TCP-Server verwendet.
Diese Verbindung wird mit einem Websocket gemanagt.
Somit müssen keine speziellen Nachrichten gesendet werden, da alle dauerhaft verbunden sind und alle die gleichen Nachrichten erhaltne (Broadcast).
Der Server läuft auf dem BeagleBoneBlack und ist für die Kommunikation mit den anderen Baugruppen zuständig. Dies ist in Bild 2 - Kommunikation zu sehen. 
Der Computer, Esp32_top, Esp32_front und Mando sind alle Clients, welche sich mit dem Server verbinden.
Sobald daten an einer Stelle geändert werden, werden diese an den Server gesendet und dieser wird dann diese Daten an die anderen Clients weiterleitet.

2.2 Kommunikation für Video
Die Kommunikation der Videodaten wird nur einseitig ablaufen. 
Heißt die jeweiligen Esps machen einen eigenen Webservers auf. 
Über diesen Webserver Streamen sie dann ihre Videos auf eine spezielle IP-Adresse.
Diese Videodaten können dann von den jeweiligen Clienten (GUI und Mando) , welche das Video brauchen, gestreamt werden.
Dies ist Bild 3 - Kommunikation Video zu sehen.

3. Aufbau der Schnittstellen und Variablen innerhalb des Rovers und der andern Baugruppe
dieses Unterkapitel dient noch einmal zur Übersicht des Rovers mit der einzelnen Sensoren und Aktoren und Baugruppen.
Die schematische Abbildung des Rovers ist in Bild 4 - schematischer Aufbau des Rovers zu sehen.
Hier ist einfach zu erkennen, wo welche Variablen sich befinden und welche Schnittstellen und Kommunikation Protokolle verwendet werden.
Dieser schematische Aufbau der Komponenten und Variablen hat das Arbeiten im Team deutlich vereinfachen.

4. Struktureller Aufbau der Software der einzelnen Baugruppen
4.1 Struktureller Aufbau der Software BBB
Da wir den BeagleBone als Server ausgewählt haben, wird hier die meiste Arbeit verrichtet.
Heißt der BeagleBone übernimmt die Komunication und die Verarbeitung der Daten.
Desweitern haben wir uns für ein Eventbasierten Ablauf entschieden, da die verschiednen Baugruppen und Komunication vereinfacht.
Heißt für jede Action wird ein Event ausgelöst in welchem dann die Action bearbeitet wird. 
Dies ist in Abbildung 5 - Event Ablauf BBB zu sehen.
Somit haben wir Beispielsweise ein Zeit gesteuertes Event für die Verarbeitung der Sensor Signalen und Actoren, 
ein zweit getacktetes event für das Brodcasten der Nachriten. 
Auf alle einzelnen Events wird nun genauer eingangen:
1. Event Sensoren
Dieses Event ist Zeit gesteuert. Wenn das TimerEvent ausgelöst wird werden alle Sensoren nacheinander abgefragt.
Zu diesen Sensoren gehören der Light Sensor, der Temperatur Sensor, der Ultraschall Sensor.
Anschließend werden die Daten in die Datenclasse übergeben.
2. Event Actoren
Dieses Event ist auch Zeit gesteuert. Wenn das TimerEvent ausgelöst wird werden alle Actoren nacheinander angesteuert. 
Zu den Actoren gehören Led, Ventilator, Lautsprecher.
Anschließend werden die Daten in die Datenclasse übergeben.
3. Event Comunication
Diese Events werden immer ausgelösst wenn ein Client versucht mit unserem Server zu interagieren.
3.1 Event OnConnectionRequest()
Wenn ein Client versucht sich mit dem Server zu verbinden, wird dieses Event ausgelöst.
Dann wird der Client in unsere liste von Socket verbindungen aufgenommen.
3.2 Event OnDataReceived()
Wenn ein Client Daten an den Server sendet, wird dieses Event ausgelöst.
Dann werden die Daten in die Datenclasse übergeben und die Daten dann auch an die weitern Module wie FPGA oder Trajectory weiter gegeben.
3.3 Event OnSendData()
Dises Event ist zum Senden an alle Clients gedacht.
Man kann verschiedene Nachrichten an alle Clients senden.
In unserem Fall wird über dieses Event die Log_datei und die Config_datei an alle Clients gesendet.
3.4 Event OnDisconnected()
Wenn ein Client sich vom Server trennt, wird dieses Event ausgelöst.
Dann wird der Client aus unserer Liste von Socket verbindungen entfernt.
4. Event Loggen
Die grund Funktion ist recht einfach.
Die gesamte Logg Nachricht wird in einer Zeile geschrieben.
Es wird immer zu erst die Uhrzeit und dann das Datum geschrieben.
Anschließend wird die Nachricht geschrieben.
Die Nachricht soll kurz beschreiben was passiert.
Folgende Nachrichten werden geloggt:
- Client hat sich mit dem Server verbunden
- Client hat sich vom Server getrennt
- Room_light turned on/off with the room_name
- Alarm turned on/off
- pusher activated

4.2 Struktureller Aufbau der Software Esp32_top
4.3 Struktureller Aufbau der Software Esp32_cam
4.4 Struktureller Aufbau der Software Mando
4.5 Struktureller Aufbau der Software GUI

5. Erklärung der einzelnen Klassen
5.1 Klasse BeagleBone
In dieser Klasse werden alle Aufgaben welche der BeagleBone übernimmt umgesetzt. 
Als auch die Deklarierung der einzelnen GPIO Pins und die Methoden für die Leds, Fans, Temeratur, Abstrandsensor (Ultraschallsensor) übernommen. 
Folgende Methoden sind in dieser Klasse enthalten:
void BeagleBone::Leds_on(); - einschalten der Leds mit der rc lib um 3,3V auf den Ausgangspin zu legen. 
void BealgeBone::Leds_off(); - ausschalten der Leds mit der rc lib um 0V auf den Ausgangspin zu legen. 
void BealgeBone::Fans_on(int frecuencia, float duty); - die Lüfter werden über eine PWM angestuert. Dafür werden Frquenzy und duty_cycle übergeben.
void BeagleBone::Fans_off(); - die Lüfter werden ausgeschalten.
double BeagleBone::Temerature(); - es wird der Temeratur Sensor ausgelesen mit der rc lib dem Analog Read.
float BeagleBone::Position(Proximity_Detectors ultrasound); - es wird der Abstrand von der nächsten wand bestimmt der Ultrasound Bibliothek.
Follgende Solots sind in dieser Klasse enthalten:
void BeagleBone::onTimerControll(); - wird aufgerufen wenn das TimerEvent Controll ausgelöst wird. übernimmt alle GPIO pin outputs.
void BeagleBone::onTimerSensor(); - wird aufgerufen wenn das TimerEvent Sensor ausgelöst wird. übernimmt alle GPIO pin inputs. 

5.2 Klasse Utility
Diese Klass ist da um die Verarbeitung von xml Nachrichten zu erleichtern. Dazu gibt es einige Methode:
int Utility::GetXmlInt(const QString& textXml,const QString& tag); - returns a int of the value of the tag
float Utility::GetXmlFloat(const QString& textXml,const QString& tag); return a float of the value of the tag
QVector<float> Utility::GetXmlVector(const QString& xml,const QString& tag); - returns a vector of the value of the tag
QString Utility::GetXmlTag(const QString& text); - returns the tag of the xml
QString Utility::GetXmlStr(const QString& text, const QString& tag); - returns a string of the value of the tag
QString Utility::GetXmlStr(const QString &textXml, const QString &tagXml1, const QString &tagXml2); - returns a string of the value of the tag of the tag so a xml with depth 2

5.3 Klasse Connection
Diese Klasse ist da um die Verbindung zwischen den einzelnen Clients und dem Server zu realisieren.
Dazu gibt es Folgende Methoden diese methoden sind alles Slots und werden von events getriggert:
void Connection::OnConnectionRequest(); when a client tries to connect to the server this slot is used.
 we check if we have the client in our client vector if not we add him. if we have him we overwrite the last connection.
void Connection::OnDataReceived(); - when a client sends data to the server this slot is used. we read the data and also process the message. 1. Write the new data in the Data Calss
2. send it to the other modules like fpga or trajectory or triggger an event.
void Connection::OnDisconnected() - when a client disconnects from the server this slot is used. we remove the client from our client vector.
void Connection::OnSendData(QString txt) - this slot is used to send data to all clients. we send the data to all clients in our client vector.
The Argument QString txt is the data we send.

5.5 Klasse Data
Diese Klasse ist eine reine Datenklasse und besteht aus einzelnen Structs für die einzelnen Module. Sie enthält alle Daten die zwischen den einzelnen Modulen übergeben werden.
Aus dieser Daten Klasse werden dann immer die nachriten welche an die Clients gesendet werden erstellt. Die Module sind in allen Master und Clients gleich aufgebaut.
Folgende Daten sind in dieser Klasse enthalten:
struct motor_driver_struct{
        QString motor_speed_left;
        QString motor_speed_right;
    };
    struct esp32_top_struct {
        QString ip;
        QString port;
        QString video;
        QString video_quality;
        QString pulsar;
    };
    struct esp32_front_struct {
        QString ip;
        QString port;
        QString video;
        QString video_quality;
    };
    struct fpga_struct {
        QString direction_elev;
        QString frecuency_switch;
        QString enable_elev;
        QString enable_cam;
        QString direction_cam;
    };
    struct beaglebone_struct {
        QString broadcast_time;
        QString controller_time;
        QString sensor_time;
        QString log_time;
        QString temperatur;
        QString battery;
        QString led_light;
        QString ventilator;
        QString speaker;
        QString zero_pos_low;
        QString x_pos_momento;
        QString y_pos_momento;
        QString ultrasound_right;
        QString ultrasound_left;
        QString room_light;
        QString room_name;
    };
    struct gui_struct{
        QString ip;
    };
    struct mando_struct
    {
        QString ip;
    };
    struct trajectory_struct{
        QString joy_x;
        QString joy_y;
        QString vel_max;
    };
Folgende methoden sind in dieser Klasse enthalten:
bool Data::readInitAll(const QString& xml_data); - reads the xml data and writes it in the data class
Folgende Slots sind in dieser Klasse enthalten:
void Data::OnTimer(); - here we make the xml from the data class and then emit the Signal sendToPC with the xml data as message.
Folgende Singale sind in dieser Klasse enthalten:
void Data::sendToPC(QString msg); - emit the Signal to Send the xml data to the clients.


5.6 Klasse MotorDriver
5.7 Klasse Trajectory
5.8 Klasse FPGA
